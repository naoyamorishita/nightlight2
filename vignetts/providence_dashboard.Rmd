---
title: "Analysis of Nightlight in Providence RI"
author: "Naoya Morishita"
output: flexdashboard::flex_dashboard
---
 
Introduction{}
=====================================
Column
-------------------------------------
### Introduction
This dashboard is a part of USF project in Clark University, and we want to answer to the question "Are Neighborhoods with Public Housing Projects Brighter?" using Providence RI as a case study.

#### Datasets
Here is a list of datasets that will be used

- Artificial Light at Night (ALAN) Radiance Data from [NASA](https://www.earthdata.nasa.gov/learn/backgrounders/nighttime-lights) 
- NDVI in May 2023 from [Landsat8](https://www.usgs.gov/landsat-missions/landsat-8)
- Population Data in 2020 from [Census Data](https://www.census.gov)
- Public Housing Data updated in 2023 from [HUD](https://www.huduser.gov/portal/datasets/assthsg.html#2009-2022_data)
- Building Footprint Data from [RI GIS Portal](https://www.rigis.org/datasets/building-footprints)

#### Workflow
This study will follow [a previous study](https://github.com/agroimpacts/USFlite/blob/main/external/notebooks/nightlights-part2.md) done by Dr. Estes et al at Clark University, and this will:

1. Plotting rasters of the variables
2. Exploring relations between the ALAN radiance and the other variables using scatter plot and linear regression line
3. Comparing medians of the ALAN radiance from cells, which have similar population, between with/ without public housings.

Additionally, I will try to create cross- tabulation map of the classification of the light and population.

The project was mainly done with [the R Language (R Core Team, 2022)](https://www.R-project.org/).

```{r, include = F}
# Reading Rasters====
library(geospaar)
library(leaflet)
library(flexdashboard)

alan <- raster::raster("./data/providence_ri/mean_all.TIF")
ndvi <- raster::raster("./data/providence_ri/ndvi.tif")
pop <- raster::raster("./data/providence_ri/pop_grid.tif")
bld <- raster::raster("./data/providence_ri/bld_density.tif")
ph_area <- raster::raster("./data/providence_ri/ph_area_grid.tif")

# Aligning Rasters====
r_list <- list(alan, ndvi, pop, bld, ph_area) # creating list # for the loop

for (i in 1:length(r_list)){
  extent(r_list[[i]]) <- extent(alan) # aligning extent
  crs(r_list[[i]]) <- crs(pop) # aligning crs
}

# Creating a Raster Brick====
b <- brick(r_list)

# Creating a Polygon from the Brick====
p <- rasterToPolygons(b %>% scale()) %>% # converting raster to polygon # after scaling # for regression analysis
  st_as_sf() %>% 
  na.omit(.) %>% # removing na values
  rename(alan = layer.1, # making columns "meaningful" 
         ndvi = layer.2,
         pop = layer.3,
         bld = layer.4,
         ph_area = layer.5)

pop <- st_read("/Users/naoyamorishita/Documents/working/nightlight/data/providence_ri/population_tract.geojson") %>% 
  st_as_sf() %>% 
  st_transform(crs = 4326)
php <- st_read("/Users/naoyamorishita/Documents/working/nightlight/data/providence_ri/ph_pt.geojson") %>%
  st_as_sf() %>%
  st_transform(crs = 4326)
crs(alan) <- crs(pop)
colors <- c("#593C19", "#D97904", "#F2A30F", "#F2BC1B", "#F2CE16") # creating color palette
at <- seq(0, 2500, 500) # for splitting values (max 3000) into every 600
cb <- colorBin(palette = colors, bins = at, domain = at) # creating color bin # assigning colors to classification

pop_colors <- c("#042940", "#005C53","#9FC131","#DBF227","#D6D58E", "#F2E3D5" )
pop$ total <- as.numeric(pop$ total)
pop$ area <- pop %>% st_transform(crs = 6567) %>% 
  st_area() %>% 
  units::set_units("km^2")
  as.numeric()
pop$ total <- as.numeric(pop$ total)
pop$ pop_dense <- pop$ total/ pop$ area
pop_at <- c(0, 1500, 2500, 3500, 5000, 7500, 10000) # for splitting values (max 3000) into every 600
pop_pal <- colorBin(pop_colors, domain = pop$ pop_dense, bins = pop_at)
labelling1 <- function(geoid, total){ 
  paste0("<b>GEOID: </b>", 
        geoid, 
        "<br>", 
        "<b>Population Density(/ km~2): </b>", # showing "Area (mile^2)" in bold font
        total# showing area
  )}

labelling2 <- function(occu){
  paste0("<b>Total Occupancy: </b>",
         occu)
}


osm <- leaflet() %>% 
  addProviderTiles(providers$OpenStreetMap)



crs(ndvi) <- crs(pop)
crs(bld) <- crs(pop)
bld_col <- c("#BBE8F2", "#94D7F2", "#5FB6D9", "#3D9DD9", "#2685BF")
bld_at <- c(0, 5000, 10000, 25000, 50000, 150000)
bld_cb <- colorBin(palette = bld_col, bins = bld_at, domain = bld_at)

ndvi_col <- c("#F2E7DC", "#A9D9D0", "#038C7F", "#027373")
ndvi_at <- seq(-0.1, 0.5, 0.15)
ndvi_cb <- colorBin(palette = ndvi_col, bins = ndvi_at, domain = ndvi_at) 
```

Column2
-------------------------------------
### Basic Maps
```{r}
# Adding BaseMap====
# Adding Raster & Legend
m <-
osm %>%
  addRasterImage(x = alan, # data
                 opacity = 0.8, # opacity
                 colors = colors,
                 group = "ALAN") %>% # color palettefrom the previous chunk
  addLegend(pal = cb, # palette
            values = at, # steps
            title = "Monthly ALAN Ave for 10yrs",
            group = "ALAN") %>%  # title
  addPolygons(data = pop,
              color = "#593C19",
              opacity = 0.1,
              weight = 2,
              fillOpacity = 0.8,
              fillColor = ~pop_pal(pop_dense),
              popup = ~labelling1(geoid = GEOID, total = pop_dense),
              group = "PopDensity") %>% 
    addLegend(pal = pop_pal, 
            values = pop$ pop_dense, 
            opacity = 0.7, 
            title = "Population Density",
            group = "PopDensity") %>% 
  addCircleMarkers(data = php,
                   color = "#149BCC",
                   radius = 5,
                   stroke = F,
                   opacity = 1,
                   popup = ~labelling2(occu = TOTAL_OCCUPIED),
                   group = "Public Housing") %>% 
  addRasterImage(x = bld, # data
                 opacity = 0.8, # opacity
                 colors = bld_col,
                 group = "Building Volume") %>% # color palettefrom the previous chun
  addLegend(pal = bld_cb, # palette
            values = bld_at, # steps
            title = "Building Volume (m^2)",
            group = "Building Volume") %>%  # title
  addRasterImage(x = ndvi, # data
                 opacity = 0.8, # opacity
                 colors = ndvi_col,
                 group = "NDVI") %>% # color palettefrom the previous chun
  addLegend(pal = ndvi_cb, # palette
            values = ndvi_at, # steps
            title = "NDVI",
            group = "NDVI") %>%  # title
  addLayersControl(overlayGroups = c("PopDensity", "Building Volume", "NDVI", "ALAN", "Public Housing"),
                   position = "topleft")
m %>% 
  hideGroup(c("PopDensity", "Building Volume", "NDVI"))
  
```

Result{}
=====================================
Column1
-------------------------------------
### Description
#### CrossTab
This showed the a tabulation of estimated population and the ALAN radiance. Here are some findings:

- High/ High overlaps distributed across north and south of the center.
  - We can see some clusters there.
- Areas with small population but high ALAN radiance are shown along the riverside/ waterfront. 
  - These could be commercial districts.
  - Interestingly, some public housings are located in the area.

#### Box Plot: Comparison of Medians
This section compares the ALAN radiance from grids having similar size of population between with/ without public housings. Although the number of those with public housings are smaller, their median is larger in 4 classes out of 5.

#### Correlations

Here are summaries from the visuals. We can see:

- strongly positive correlations between the ALAN  and building density/ population.
  - Nevertheless, the correlations between volumes of population and radiance **from grids with public housings are random!!!**
- strongly negative correlations between the ALAN and NDVI.

Column2 {.tabset .tabset-fade}
-------------------------------------

### CrossTab
```{r, width = 50, height = 60}
p_reclass <- b %>% 
  rasterToPolygons() %>% # conversion
  st_as_sf() %>% 
  na.omit(.) %>% # removing na
  select(alan = layer.1, # saving necessary columns # after renaming them
         ndvi = layer.2,
         pop = layer.3,
         bld = layer.4,
         ph = layer.5)

# Reclassifying Values====
# Population----
pop_level <- p_reclass %>% 
  pull(pop) %>% # using population column
  quantile(.,
           probs = seq(0, 1, 0.33)) # creating classes every 33 percentiles

light_level <- p_reclass %>% 
  pull(alan) %>% 
  quantile(.,
           probs = seq(0, 1, 0.33))

p_reclass <- p_reclass%>%  
  mutate(pop_class = ifelse(pop < pop_level[2], 1, # assigning 1 if falls into the 1st 33percentiles
                     ifelse(pop < pop_level[3], 2, 3)) %>%
           as.character(), # converting into character # for concatnation
         alan_class = ifelse(alan < light_level[2], 1, # same as above
                      ifelse(alan < light_level[3], 2, 3)) %>%
           as.character(),
         alan_pop = paste0(pop_class, alan_class) %>% # concatnating pop class and alan class
           as.integer()) # back to integer

# Creating a raster----
alan_pop_raster <- rasterize(p_reclass,
                             b,
                             field = "alan_pop")

# Reclassifying a raster----
rec <- cbind(sort(unique(p_reclass$ alan_pop)-1), # creating reclassification matrix: from
             sort(unique(p_reclass$ alan_pop)), # creating reclass mtx: to
             1:length(unique(p_reclass$ alan_pop))) # assigning new categorical values

alan_pop_class <- reclassify(x = alan_pop_raster, # reclassifying the lightph_crstbr
                            rcl = rec, # by using the reclassification mtx
                            include.lowest = TRUE) # including the floor values in each class

col <- c("#A7E7F6", "#318EAD", "#225A76", "#F2CE16", "#F2A30F", "#D97904", "#F2BDC7", "#D93B58", "#BF0F1E")
class <- c("Low/ Low", "Low/ Med", "Low/ High", "Med/ Low", "Med/ Med", "Med/ High", "High/ Low", "High/ Med", "High/ High")
at <- seq(1, 10, 1) # for splitting values (max 3000) into every 600
cb <- colorBin(palette = col, bins = 9, domain = at) # creating color bin # assigning colors to classification

crs(alan_pop_class) <- crs(alan)
leaflet(height = "60%") %>% 
  addProviderTiles(providers$OpenStreetMap) %>% 
  addRasterImage(x = alan_pop_class, # data
                 opacity = 0.8, # opacity
                 colors = col) %>% # color palettefrom the previous chunk
  addLegend(pal = cb, # palette
            values = at, # steps
            title = "Population/ ALAN",
            labFormat = function(type, cuts, p){
              paste0(class)
            }) %>% # title
  addCircleMarkers(data = php,
                   color = "#6BBE49",
                   radius = 5,
                   stroke = F,
                   opacity = 1,
                   group = "Public Housing Locations") %>% 
  addLayersControl(overlayGroups ="Public Housing Locations",
                   options = layersControlOptions(collapsed = FALSE))
  
```

### Box Plot: Comparison of Medians
Note that the values are scaled.
```{r}
pop_q <- p %>% 
  pull(pop) %>% # using pop column
  quantile(., # calculating quantile
           probs = seq(0, 1, 0.2)) # making class every 20 percentiles

df <- st_drop_geometry( # creating data frame
  p) %>% # after dropping geometry from polygon
  as.data.frame() # saving as a data frame

df <- df %>% 
  mutate(pop_class = # creating a new column of pop class
           ifelse(pop < pop_q[2], 1, # assigning 1 if it falls into the first section
           ifelse(pop < pop_q[3], 2,
           ifelse(pop < pop_q[4], 3,
           ifelse(pop < pop_q[5], 4, 5)))) %>% # assigning 5 if it falls into the last sectino
           as.factor() # converting into factor # ie categorical values
)

# Assigning ph status----
df <- df %>% 
  mutate(ph_level = ifelse(ph_area > -0.2218275, "PH", "NoPH")) # assigning public housing class

# Creating box plots----
df %>% 
  ggplot() + geom_boxplot(aes(x = pop_class, # putting pop level on x
                              y = alan, # putting radiance on y
                              fill = ph_level)) + # dividing by ph_status
  xlab("Population Level") + # adding x label
  scale_fill_manual(values = c("#F2B807", "#AED952")) # adding colors
```


### Correlations
Note that the values are scaled.
```{r}
library(GGally)
ggpairs(df, columns = 1:4, ggplot2::aes(colour=ph_level))
```
