---
title: "Are Neighborhoods with Public Housing Projects Brighter?(Phoenix AZ)"
author: "Naoya Morishita"
---
# Introduction
## Introduction
This exercise will look at brightness values across the city of Phoenix Arizona, and compare the values between grids with and without public housings, referring to [this case study](https://github.com/agroimpacts/USFlite/blob/main/external/notebooks/nightlights-part2.md
).

## Datasets
- The Monthly Average [night lights between 2012-2023 from NASA](https://www.earthdata.nasa.gov/learn/backgrounders/nighttime-lights)
- SAVI from the [Landsat8](https://www.usgs.gov/landsat-missions/landsat-8)
- Gridded Population from [the US Census in 2020](https://www.census.gov/topics/population.html)
- Gridded Public Housing Density Estimated from [HUD Data](https://www.huduser.gov/portal/datasets/assthsg.html#2009-2022_data) & [Microsoft Building Footprint Data](https://github.com/microsoft/USBuildingFootprints)
- Gridded Building Density Data from [USGS](https://www.sciencebase.gov/catalog/item/5d27a8dfe4b0941bde650fc7)

## Showing Data
```{r, include = F}
library(geospaar)
library(leaflet)
library(flexdashboard)
nl <- raster::raster("data/total_mean.tif")
savi <- raster::raster("data/savi_2206.tif")
pop <- raster::raster("data/pop_grid.tif")
ph <- raster::raster("data/ph_density.tif")
bld <- raster::raster("data/bldr.tif")
extent(pop) <- extent(nl)
l <- list(nl, savi, pop, ph, bld)
for (i in 1:length(l)){
  crs(l[[i]]) <- crs("epsg:26949")
}
b <- brick(l)
names(b) <- c("NightLight", "SAVI", "Population", "PublicHousing", "Building")
```
```{r}
plot_noaxes(b)
```

# Analysis
## Showing Relations: With Regression
Now, we are going to plot the relations between the nighttime light radiance and the other variables with `ggplot2`. Note that the values are all scaled. Here are some of major findings:

- Medium positive correlation between nightlight and population/ public housing (filtered)
- Small positive and negative correlation between nightlight and building volume/ SAVI, respectively
- Random correlations between nightlight and public housing
```{r, fig.width=10, fig.height=6, fig.align = "left", warning = FALSE, message = FALSE}
# Converting into Spatial DataFrame after Rescaling the Values====
p_scaled <- b %>% 
  raster::scale(.) %>% 
  rasterToPolygons(.) %>% 
  st_as_sf %>% 
  na.omit(.) %>% 
  mutate(PhLevel = ifelse(PublicHousing > -0.02972701, "Y", "N"))

# Creating Plots====
# Creating a plot of savi----
g1 <- p_scaled %>% # creating a plot and save it as a variable
  ggplot(aes(x = SAVI, y = NightLight))+ # placing savi on x and nightlight on y
  geom_jitter(color = "peru")+ 
  geom_smooth(color = "seagreen",
              method = "lm")+ # using linear regression
  ggtitle("SAVI vs NightLight", # placing a main title
          subtitle = paste0("Coef: ", # placing a subtitle with str concatnation with coef
                            cor(p_scaled$ NightLight, # calculating correration coef of nightlight and 
                                p_scaled$ SAVI)))+ # savi
  xlab("SAVI")+ # placing x label
  ylab("Nightlight") # placing ylabel
# g1

# Creating a plot of population----
g2 <- p_scaled %>% 
  ggplot(aes(x = Population, y = NightLight))+ 
  geom_jitter(color = "peru")+ 
  geom_smooth(color = "seagreen",
              method = "lm")+ 
  ggtitle("Population vs NightLight", 
          subtitle = paste0("Coef: ", 
                            cor(p_scaled$ NightLight, 
                                p_scaled$ Population)))+ 
  xlab("Population")+ 
  ylab("Nightlight")
# g2

# Creating a plot of public housing (all)----
g3 <- p_scaled %>% 
  ggplot(aes(x = PublicHousing, y = NightLight))+ 
  geom_jitter(color = "peru")+ 
  geom_smooth(color = "seagreen",
              method = "lm")+ 
  ggtitle("Public Housing vs NightLight", 
          subtitle = paste0("Coef: ", 
                            cor(p_scaled$ NightLight, 
                                p_scaled$ PublicHousing)))+ 
  xlab("PublicHousing")+ 
  ylab("Nightlight")
# g3

# Creating a plot of public housings (filtered)----
p_filtered <- p_scaled %>% # creating a new table 
  filter(PhLevel == "Y") # containing only those with ph

g3_2 <- p_filtered %>% 
  ggplot(aes(x = PublicHousing, y = NightLight))+ 
  geom_jitter(color = "peru")+ 
  geom_smooth(color = "seagreen",
              method = "lm")+ 
  ggtitle("Public Housing vs NightLight (Filtered)", 
          subtitle = paste0("Coef: ", 
                            cor(p_filtered$ NightLight, 
                                p_filtered$ PublicHousing)))+ 
  xlab("PublicHousing")+ 
  ylab("Nightlight")
# g3_2

# Creating a plot of total building volumes----
g4 <- p_scaled %>% 
  ggplot(aes(x = Building, y = NightLight))+ 
  geom_jitter(color = "peru")+ 
  geom_smooth(color = "seagreen",
              method = "lm")+ 
  ggtitle("Building Voume vs NightLight", 
          subtitle = paste0("Coef: ", 
                            cor(p_scaled$ NightLight, 
                                p_scaled$ Building)))+ 
  xlab("Building Volume")+ 
  ylab("Nightlight")
# g4

# Creating a heatmap of correlation coef----
# library(GGally)
# g5 <- ggcorr(p_scaled[, 1:5] %>% # using only first 5 columns
#                st_drop_geometry(), # converting sf into df # for avoiding error
#              method = c("everything", "pearson"),
#              legend.size = 1)
# # g5

# Showing the Graphs in CowPlots====
cowplot::plot_grid(g1, g2, g3, g3_2, g4, # g5, # adding 5 plots
                   nrow = 3, # with 3 rows
                   align = "vh", # vertically & horizontally alligned
                   axis = "l") # aligned to left
```

## Comparing Radiances: Boxplots
The following codes compare median radiance from similar population and building density in between grids with/ without public housing to answer the question of "Are Neighborhoods with Public Housing Projects Brighter?"
The steps are:

1. Calculate 1/3 and 2/3 percentiles of population and building density separately to assign levels
2. Divide the data frame into grids with ph and without.
3. Assign the levels to each grid to classify 9 levels (Population: low & Density: low, Population: Middle & Density: Low etc...)
4. Compare medians from all classes between those with and without public housings.

The result seems to be:
- There is no record of grids with public housings for level 1 and 4
- However, the radiance from grids with public housing is higher in 4 out of the other 7 levels.
```{r, fig.width=10, fig.height=6, fig.align = "left", warning = FALSE, message = FALSE}
# Preparing for Analysis====
# Calculating 33% quantiles----
pop_q <- p_scaled %>% 
  pull(Population) %>% # using pop column
  quantile(., probs = seq(0, 1, 1/3)) # setting probabilities for making every 0.2 threshold

bld_q <- p_scaled %>% 
  pull(Building) %>% 
  quantile(., probs = seq(0, 1, 1/3))

# Defining which class the records belong to----
popvol <- p_scaled %>% 
  mutate(., pop_class = cut(Population, pop_q, include.lowest = T, dig.lab = 4)) %>% 
  mutate(., bld_class = cut(Building, bld_q, include.lowest = T, dig.lab = 2))

# Counting the numbers of each class with crosstaburation----
tab_original <- table(pop = popvol$ pop_class, 
             bvol = popvol$ bld_class) %>% 
  as.data.frame(.)

# Creating a from to table----
tab <- tab_original %>% 
separate(., col = pop, into = c("pop_l", "pop_u"), sep = ",") %>% 
  separate(., col = bvol, into = c("bvol_l", "bvol_u"), sep = ",") %>% 
  mutate(., pop_l = as.numeric(gsub("\\(|\\[", "", pop_l))) %>%
  mutate(., pop_u = as.numeric(gsub("\\]", "", pop_u))) %>%
  mutate(., bvol_l = as.numeric(gsub("\\(|\\[", "", bvol_l))) %>% 
  mutate(., bvol_u = as.numeric(gsub("\\]", "", bvol_u))) %>% 
  filter(., Freq > 1)

# Dividing into Grids with Ph and without====
no_ph_df <- lapply(1: nrow(tab), 
                function(x){
                  l <- tab[x, ] 
                  # print(l)
                  p_scaled %>% 
                    filter(PhLevel == "N") %>% 
                    filter(between(Population, 
                                   l$ pop_l,
                                   l$ pop_u)) %>% 
                    filter(between(Building,
                                   l$ bvol_l,
                                   l$ bvol_u)) %>% 
                    mutate(level = factor(x))
                }) %>% 
  bind_rows()
print(no_ph_df[1:5,])

# Creagting ph df----
ph_df <- lapply(1: nrow(tab),
                function(x){
                  l <- tab[x, ] 
                  # print(l)
                  p_scaled %>% 
                    filter(PhLevel == "Y") %>% 
                    filter(between(Population, 
                                   l$ pop_l,
                                   l$ pop_u)) %>% 
                    filter(between(Building,
                                   l$ bvol_l,
                                   l$ bvol_u)) %>% 
                    mutate(level = factor(x))
                }) %>% 
  bind_rows()

# Combining the dfs----
all_df <- bind_rows(no_ph_df, ph_df)

# Creating Box Plots====
all_df %>% 
  ggplot() + geom_boxplot(aes(x = level,
                              y = NightLight, 
                              fill = PhLevel)) + 
  xlab("Population/Builsing Level") + 
  ylab("Radiance") +
  scale_fill_manual(values = c("salmon", "steelblue"))
```

### Comparing Radiances: Data Frame
```{r}
all_df %>%
  st_drop_geometry() %>% # converting sf to df
  group_by(PhLevel, level) %>% # grouping by ph level and population quantile
  summarize(MedianRadiance = median(NightLight)) %>% # calculating medians
  pivot_wider(names_from = PhLevel, values_from = MedianRadiance) %>% # adding columns for comparison
  mutate(Difference = Y - N) %>% # adding a column
  rename(PopulationBuildingLevel = level) # renaming a column
```

## Are those with Ph less or more vegetated?
Same as the above, I want to use SAVI level instead of population and building density. Note that the value is scaled. The result was that the medians of SAVI with public housing from ALL classes of similar population/ building density were lower, regardless of the median of the radiance from them.
```{r}
# Preparing for the Analysis====
# Creating savi column without scaling----
savi_p <- b[[2]] %>% 
  rasterToPolygons() %>% 
  st_as_sf() %>% 
  na.omit() %>% 
  rename(savi_original = SAVI)

all_df <- st_join(
          all_df, 
          savi_p,
          join = st_equals, 
          left = F)

# Creating light classes----
lt_q <- all_df %>% 
  pull(NightLight) %>% # using pop column
  quantile(., probs = seq(0, 1, 1/3)) # setting probabilities for making every 0.2 threshold

# Defining which class the records belong to----
ltpop <- all_df %>% 
  mutate(., lt_class = cut(NightLight, lt_q, include.lowest = T, dig.lab = 4)) %>% 
  mutate(., pop_class = cut(Population, pop_q, include.lowest = T, dig.lab = 2))

# Counting the numbers of each class with crosstaburation----
tab_original <- table(pop = ltpop$ pop_class, 
             lt = ltpop$ lt_class) %>% 
  as.data.frame(.)

# Creating a "from to" table----
tab <- tab_original %>% 
separate(., col = pop, into = c("pop_l", "pop_u"), sep = ",") %>% 
  separate(., col = lt, into = c("lt_l", "lt_u"), sep = ",") %>% 
  mutate(., pop_l = as.numeric(gsub("\\(|\\[", "", pop_l))) %>%
  mutate(., pop_u = as.numeric(gsub("\\]", "", pop_u))) %>%
  mutate(., lt_l = as.numeric(gsub("\\(|\\[", "", lt_l))) %>% 
  mutate(., lt_u = as.numeric(gsub("\\]", "", lt_u))) %>% 
  filter(., Freq > 1)

# Dividing into Grids with Ph and without====
no_ph_df <- lapply(1: nrow(tab), 
                function(x){
                  l <- tab[x, ] 
                  all_df %>% 
                    filter(PhLevel == "N") %>% 
                    filter(between(Population, 
                                   l$ pop_l,
                                   l$ pop_u)) %>% 
                    filter(between(NightLight,
                                   l$ lt_l,
                                   l$ lt_u)) %>% 
                    mutate(level = factor(x))
                }) %>% 
  bind_rows()

# Creagting ph df----
ph_df <- lapply(1: nrow(tab), 
                function(x){
                  l <- tab[x, ] 
                  all_df %>% 
                    filter(PhLevel == "Y") %>% 
                    filter(between(Population, 
                                   l$ pop_l,
                                   l$ pop_u)) %>% 
                    filter(between(NightLight,
                                   l$ lt_l,
                                   l$ lt_u)) %>% 
                    mutate(level = factor(x))
                }) %>% 
  bind_rows()

# Combining the dfs----
all_df <- bind_rows(ph_df, no_ph_df)

# Creating a Box Plots====
all_df %>% 
  ggplot() + geom_boxplot(aes(x = level,
                              y = savi_original, 
                              fill = PhLevel)) + 
  xlab("Population/Light Level") + 
  ylab("SAVI") +
  scale_fill_manual(values = c("salmon", "steelblue"))
```

### Comparing Radiances: Data Frame
```{r}
all_df %>%
  st_drop_geometry() %>% # converting sf to df
  group_by(PhLevel, level) %>% # grouping by ph level and population quantile
  summarize(MedianSAVI = median(savi_original)) %>% # calculating medians
  pivot_wider(names_from = PhLevel, values_from = MedianSAVI) %>% # adding columns for comparison
  mutate(Difference = Y - N) %>% # adding a column
  rename(PopulationBuildingLevel = level) %>%  # renaming a column
  print()
```
